
[ClassVersion("1.0.0.0"), FriendlyName("AdfsProperties")]
class MSFT_AdfsProperties : OMI_BaseResource
{
    [Key, Description("Specifies the DNS name of the federation service.")] String FederationServiceName;
    [Write, Description("Specifies the level of additional information that is displayed on ADFS error pages. This property is only supported in Windows Server 2019 and above."), ValueMap{"Private","Detailed","None"}, Values{"Private","Detailed","None"}] String AdditionalErrorPageInfo;
    [Write, Description("Specifies an array of authentication contexts, in order of relative strength. Specify each authentication context as a URI.")] String AuthenticationContextOrder[];
    [Write, Description("Specifies an array of identifiers that are acceptable names for the Federation Service when it checks the audience for claims that it receives from another claims provider.")] String AcceptableIdentifiers[];
    [Write, Description("Specifies the connection string to use for the database that maintains the artifacts that the artifact resolution service uses.")] String ArtifactDbConnection;
    [Write, Description("Specifies an array of audit levels."), ValueMap{"None","Basic","Verbose"}, Values{"None","Basic","Verbose"}] String AuditLevel[];
    [Write, Description("Indicates whether the system manages certificates for the administrator and generates new certificates before the expiration date of current certificates.")] Boolean AutoCertificateRollover;
    [Write, Description("Specifies the period of time, in days, prior to the expiration of a current primary signing or decryption certificate. When a certificate reaches this threshold, the Federation Service initiates the automatic certificate rollover service, generates a new certificate, and promotes it as the primary certificate. This rollover process occurs even if the critical threshold interval does not provide sufficient time for partners to replicate the new metadata. Specify a short period of time that is used only in extreme conditions when the Federation Service has not been able to generate a new certificate in advance.")] Sint32 CertificateCriticalThreshold;
    [Write, Description("Specifies the period of time, in days, that any certificates that the Federation Service generates remain valid.")] Sint32 CertificateDuration;
    [Write, Description("Specifies the period of time, in days, that any certificates that the Federation Service generates remain valid. The default value is 365 days.")] Sint32 CertificateGenerationThreshold;
    [Write, Description("Specifies the period of time, in days, during which a newly generated certificate remains a secondary certificate before being promoted as the primary certificate. The default value is 5 days.")] Sint32 CertificatePromotionThreshold;
    [Write, Description("Specifies the certificate rollover interval, in minutes. This value determines the frequency at which the Federation Service initiates the rollover service by polling to check whether new certificates need to be generated. The default value is 720 minutes.")] Sint32 CertificateRolloverInterval;
    [Write, Description("Specifies the certificate threshold multiplier. By default, this parameter uses the number of minutes in a day (1440) as a multiplier. Change this value only if you want to use a more finely detailed measure of time, such as less than a single day, for calculating the time periods for other certificate threshold parameters.")] Sint32 CertificateThresholdMultiplier;
    [Write, Description("Enabled the OAuth Device Flow.")] Boolean EnableOAuthDeviceFlow;
    [Write, Description("Specifies the network addressable host name of the Federation Service.")] String HostName;
    [Write, Description("Specifies the HTTP port for the server.")] Sint32 HttpPort;
    [Write, Description("Specifies the HTTPS port for the server.")] Sint32 HttpsPort;
    [Write, Description("Indicates whether all web based requests from the intranet default to the default Active Directory claims provider. Use this parameter only when there is more than one claims provider trust in AD FS and you want all user access from the intranet to use the default Active Directory for authentication.")] Boolean IntranetUseLocalClaimsProvider;
    [Write, Description("Specifies the port number where AD FS listens for user certificate authentication requests. Use this only when user certificate authentication is used in AD FS.")] Sint32 TlsClientPort;
    [Write, Description("Specifies the URI that uniquely identifies the Federation Service.")] String Identifier;
    [Write, Description("Specifies an array of log detail. The array defines which types of events to record."), ValueMap{"Errors","FailureAudits","Information","Verbose","SuccessAudits","Warnings","None"}, Values{"Errors","FailureAudits","Information","Verbose","SuccessAudits","Warnings","None"}] String LogLevel[];
    [Write, Description("Specifies the frequency, in minutes, with which the Federation Service monitors the federation metadata of relying parties and claims providers that are enabled for federation metadata monitoring.")] Sint32 MonitoringInterval;
    [Write, Description("Specifies the TCP port number for the server.")] Sint32 NetTcpPort;
    [Write, Description("Indicates whether to enable support for NTLM-based authentication in situations where the active federation server proxy does not support Negotiate method of authentication. This setting only affects the Windows transport endpoint.")] Boolean NtlmOnlySupportedClientAtProxy;
    [Write, Description("Indicates whether the Federation Service prevents the replay of security tokens.")] Boolean PreventTokenReplays;
    [Write, Description("Specifies the level of extended protection for authentication supported by the federation server. Extended Protection for Authentication helps protect against man-in-the-middle (MITM) attacks, in which an attacker intercepts a client's credentials and forwards them to a server. Protection against such attacks is made possible through a Channel Binding Token (CBT) which can be either required, allowed or not required by the server when establishing communications with clients."), ValueMap{"Require","Allow","None"}, Values{"Require","Allow","None"}] String ExtendedProtectionTokenCheck;
    [Write, Description("Specifies the valid token lifetime, in minutes, for proxy trust tokens. This value is used by the federation server proxy to authenticate with its associated federation server.")] Sint32 ProxyTrustTokenLifetime;
    [Write, Description("Specifies the cache duration, in minutes, for token replay detection. This value determines the lifetime for tokens in the replay cache. When the age of a cached token exceeds this interval, the Federation Service determines the token has expired and does not allow replay of it.")] Sint32 ReplayCacheExpirationInterval;
    [Write, Description("Indicates whether the Federation Service requires signed SAML protocol requests from the relying party. If you specify a value of $True, the Federation Service rejects unsigned SAML protocol requests.")] Boolean SignedSamlRequestsRequired;
    [Write, Description("Specifies the duration, in minutes, for which the Security Assertion Markup Language (SAML) messages sent by the Federation Service are considered valid.")] Sint32 SamlMessageDeliveryWindow;
    [Write, Description("Indicates whether the Federation Service signs SAML protocol authentication requests to claims providers.")] Boolean SignSamlAuthnRequests;
    [Write, Description("Specifies the duration, in minutes, of the single sign-on (SSO) experience for Web browser clients.")] Sint32 SsoLifetime;
    [Write, Description("Specifies the duration, in minutes, of the persistent SSO experience.")] Sint32 PersistentSsoLifetimeMins;
    [Write, Description("Specifies the lifetime of the sign on status for KMSI.")] Sint32 KmsiLifetimeMins;
    [Write, Description("Indicates whether to store the SSO token in persistent cookies for devices joined to a workplace.")] Boolean EnablePersistentSso;
    [Write, Description("Specifies the earliest issue time of accepted persistent single sign-on (SSO) tokens and OAuth refresh tokens. Persistent SSO tokens or OAuth refresh tokens issued before this time will be rejected. Use this only to reject all prior SSO state across all users and force users to provide fresh credentials.")] DateTime PersistentSsoCutoffTime;
    [Write, Description("Indicates whether to enable the Keep Me Signed In (KMSI) option for form-based authentication. KMSI is limited to providing only 24 hours of SSO. Note that a workplace joined device gets 7 days of SSO by default and does not need this option enabled.")] Boolean EnableKmsi;
    [Write, Description("Specifies an array of acceptable user agents that support seamless sign-in with Windows Integrated Authentication. If AD FS receives a token request and policy selects Windows Integrated Authentication, AD FS uses this list to determine if it needs to fall back to forms-based authentication. When the user agent for the incoming request is not in this list, AD FS falls back to forms-based authentication.")] String WIASupportedUserAgents[];
    [Write, Description("Specifies an array of user agents that are supported for browser SSO.")] String BrowserSsoSupportedUserAgents[];
    [Write, Description("Indicates that browser single sign-on (SSO) is enabled.")] Boolean BrowserSsoEnabled;
    [Write, Description("Specifies the time interval in seconds for AD FS to track multiple token requests that are occurring and being rejected by the relying party causing a redirect back to AD FS for a new token request. Use in conjunction with the LoopDetectionMaximumTokensIssuedInInterval parameter.")] Sint32 LoopDetectionTimeIntervalInSeconds;
    [Write, Description("Specifies the maximum number of tokens that can be issued within the time period specified by the LoopDetectionTimeIntervalInSeconds parameter before AD FS will reject the request and present an error to the user. Use in conjunction with the LoopDetectionMaximumTokensIssuedInInterval parameter.")] Sint32 LoopDetectionMaximumTokensIssuedInInterval;
    [Write, Description("Indicates whether to enable loop detection. Loops occur when a relying party continuously rejects a valid security token and redirects back to AD FS. The cycle terminates after 6 loops have been detected.")] Boolean EnableLoopDetection;
    [Write, Description("Specifies the maximum number of bad password attempts permitted against the directory before the account is throttled when accessing applications from the extranet for familiar locations. If you use Active Directory Domain Services account lockout policies, it is strongly recommended that you set this threshold to a value that is less than the threshold in AD DS to avoid lockout of the user inside and outside the network. This property is only supported in Windows Server 2019 and above."), ValueMap{"ADFSSmartLockoutLogOnly","ADFSSmartLockoutEnforce"}, Values{"ADFSSmartLockoutLogOnly","ADFSSmartLockoutEnforce"}] String ExtranetLockoutMode;
    [Write, Description("Specifies the maximum number of bad password attempts permitted against the directory before the account is throttled when accessing applications from the extranet for unfamiliar locations. If you use Active Directory Domain Services account lockout policies, it is strongly recommended that you set this threshold to a value that is less than the threshold in AD DS to avoid lockout of the user inside and outside the network.")] Sint32 ExtranetLockoutThreshold;
    [Write, Description("Specifies the maximum number of bad password attempts permitted against the directory before the account is throttled when accessing applications from the extranet for familiar locations. If you use Active Directory Domain Services account lockout policies, it is strongly recommended that you set this threshold to a value that is less than the threshold in AD DS to avoid lockout of the user inside and outside the network. This property is only supported in Windows Server 2019 and above.")] Sint32 ExtranetLockoutThresholdFamiliarLocation;
    [Write, Description("Indicates whether to enable the lockout algorithm for extranet. When enabled, AD FS checks attributes in Active Directory for the user before validating the credential. If the user is determined to be in lockout state, AD FS will deny the request to the user when accessing from the extranet, to prevent random login attempts from the extranet. Intranet access will continue to be validated against Active Directory.")] Boolean EnableExtranetLockout;
    [Write, Description("Specifies the timespan of the lockout observation window. AD FS will reset a throttled state of an account when more than one observation window has expired since the last bad password attempt, as reported by Active Directory Domain Services. It is also possible that the last bad password field in AD DS is cleared by AD DS based on its own observation windows. In this case, AD FS will allow the request to be passed onto AD DS for validation.")] String ExtranetObservationWindow;
    [Write, Description("Specifies whether extranet lockout requires a primary domain controller (PDC).")] Boolean ExtranetLockoutRequirePDC;
    [Write, Description("Indicates whether the client request id, or activity id, is sent as a query string on any redirect from AD FS that is sent to itself. This enables all servers in AD FS to use the same client request id when logging any messages in eventlogs, traces and audits. As a result, it is easier to troubleshoot a single request across multiple AD FS servers in the farm. The default value is $True.")] Boolean SendClientRequestIdAsQueryStringParameter;
    [Write, Description("Specifies a global relying party claims issuance policy.")] String GlobalRelyingPartyClaimsIssuancePolicy;
    [Write, Description("Indicates that local authentication types are enabled.")] Boolean EnableLocalAuthenticationTypes;
    [Write, Description("Indicates that relay state for issuing distribution point (IDP) initiated sign-on is enabled.")] Boolean EnableRelayStateForIdpInitiatedSignOn;
    [Write, Description("Specifies the delegate service administration.")] String DelegateServiceAdministration;
    [Write, Description("Indicates that system service administration is allowed.")] Boolean AllowSystemServiceAdministration;
    [Write, Description("Indicates that local administrator service administration is allowed.")] Boolean AllowLocalAdminsServiceAdministration;
    [Write, Description("Specifies the length of the device usage window in days.")] Sint32 DeviceUsageWindowInDays;
    [Write, Description("Specifies whether to enable the EnableIdPInitiatedSignonPage property.")] Boolean EnableIdPInitiatedSignonPage;
    [Write, Description("Specifies whether to ignore token binding.")] Boolean IgnoreTokenBinding;
    [Write, Description("Specifies the URI of the token issuer.")] String IdTokenIssuer;
};
